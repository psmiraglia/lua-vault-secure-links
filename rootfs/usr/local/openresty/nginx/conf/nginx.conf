# nginx.conf  --  docker-openresty
#
# This file is installed to:
#   `/usr/local/openresty/nginx/conf/nginx.conf`
# and is the file loaded by nginx at startup,
# unless the user specifies otherwise.
#
# It tracks the upstream OpenResty's `nginx.conf`, but removes the `server`
# section and adds this directive:
#     `include /etc/nginx/conf.d/*.conf;`
#
# The `docker-openresty` file `nginx.vh.default.conf` is copied to
# `/etc/nginx/conf.d/default.conf`.  It contains the `server section
# of the upstream `nginx.conf`.
#
# See https://github.com/openresty/docker-openresty/blob/master/README.md#nginx-config-files
#

#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    #include /etc/nginx/conf.d/*.conf;

    server {
        listen 80;

        location /hls {
            root /var/www;
            
            resolver 127.0.0.11 ipv6=off;

            access_by_lua_block {

                local cjson = require "cjson"
                local http = require "resty.http"
                local sha256 = require "resty.sha256"
                local str = require "resty.string"
                local hmac = require "resty.hmac"
                
                -- Generate the token
                local function _token(expires, uri, remote_addr, sig_s, tok_s)
                    local md = sha256:new()
                    md:update(expires .. uri .. remote_addr .. " " .. sig_s)
                    local signature = str.to_hex(md:final())
                    ngx.log(ngx.STDERR, "SIGNATURE: " .. signature)

                    local token = hmac:new(tok_s, hmac.ALGOS.SHA256)
                    token:update(signature)
                    return str.to_hex(token:final())
                end

                -- Fetch the secret from a remote vault (e.g. HashiCorp Vault)
                local httpc = http.new()
                local res, err = httpc:request_uri("http://vault:8200/v1/secret/data/seclink", {
                    headers = {
                        ["X-Vault-Token"] = "my-root-token"
                    }
                })

                if not res then
                    ngx.say("failed request: ", err)
                    return
                end

                local sig_s = cjson.decode(res.body)["data"]["data"]["sig_secret"]
                local tok_s = cjson.decode(res.body)["data"]["data"]["tok_secret"]
                ngx.log(ngx.STDERR, "FETCHED SECRETS: " .. sig_s .. ", " .. tok_s)

                -- Get the current time
                local now = ngx.time()
                ngx.log(ngx.STDERR, "NOW: " .. now)

                -- Read the expiration time from the query string
                local arg_e = ngx.var.arg_e
                ngx.log(ngx.STDERR, "EXPIRES: " .. arg_e)

                -- Read the signature from the query string
                local arg_t = ngx.var.arg_t
                ngx.log(ngx.STDERR, "TOKEN: " .. arg_t)

                -- Get the remote address
                local remote_addr = ngx.var.remote_addr
                ngx.log(ngx.STDERR, "REMOTE ADDR: " .. remote_addr)

                -- Get the request URI
                local uri = ngx.var.uri
                ngx.log(ngx.STDERR, "URI: " .. uri)

                -- If all the parameters  have a value...
                if uri and arg_t and arg_e and tonumber(arg_e) ~= nil then
                    -- If the link is still valid...
                    if tonumber(arg_e) >= now then
                        -- Locally compute the token
                        local local_t = _token(arg_e, uri, remote_addr, sig_s, tok_s)
                        ngx.log(ngx.STDERR, "COMPUTED TOKEN: " .. local_t)

                        -- Compare with the received one
                        if arg_t ~= local_t then
                            ngx.exit(ngx.HTTP_FORBIDDEN)
                        end
                    else
                        ngx.exit(ngx.HTTP_FORBIDDEN)
                    end
                else
                    ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
            }   
        }
    }
}
